#!/bin/bash
# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘  cleave v3 â€” Infinite context for Claude Code (Plugin Edition)          â•‘
# â•‘                                                                         â•‘
# â•‘  Thin launcher that runs Claude Code with the cleave plugin.            â•‘
# â•‘  All handoff intelligence lives inside the plugin (skills, hooks,       â•‘
# â•‘  commands). This script just manages the session loop.                  â•‘
# â•‘                                                                         â•‘
# â•‘  Usage:  cleave [options] <initial-prompt-file>                         â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

set -uo pipefail

VERSION="3.0.0"

# â”€â”€ Defaults â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
MAX_SESSIONS=10
WORK_DIR="."
PAUSE_SECONDS=10
COMPLETION_MARKER="ALL_COMPLETE"
RELAY_DIR=".cleave"
VERBOSE=false
GIT_COMMIT=false
NOTIFY=true
RESUME_FROM=0
RATE_LIMIT_MAX_WAIT=18000
VERIFY_CMD=""
SKIP_PERMISSIONS=true
KNOWLEDGE_KEEP_SESSIONS=5
PLUGIN_DIR=""

# Resolve plugin directory (where this script lives)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [ -d "$SCRIPT_DIR/.claude-plugin" ]; then
    PLUGIN_DIR="$SCRIPT_DIR"
elif [ -d "$SCRIPT_DIR/cleave-plugin/.claude-plugin" ]; then
    PLUGIN_DIR="$SCRIPT_DIR/cleave-plugin"
fi

# â”€â”€ Colors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
DIM='\033[2m'
BOLD='\033[1m'
NC='\033[0m'

# â”€â”€ Parse arguments â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
usage() {
    cat << EOF
${BOLD}cleave${NC} v${VERSION} â€” Infinite context for Claude Code (Plugin Edition)

${BOLD}USAGE${NC}
  cleave [options] <initial-prompt-file>

${BOLD}OPTIONS${NC}
  -m, --max-sessions N      Maximum sessions (default: 10)
  -d, --work-dir DIR        Working directory (default: .)
  -p, --pause N             Seconds between sessions (default: 10)
  -c, --completion-marker   String signaling task completion (default: ALL_COMPLETE)
  -g, --git-commit          Auto-commit after each session
      --no-notify           Disable desktop notifications
  -r, --resume-from N       Resume from session N (reuse last handoff)
      --verify CMD          Verify completion with CMD (exit 0 = done)
      --safe-mode           Require Claude Code permission prompts
      --plugin-dir DIR      Path to cleave plugin directory
  -v, --verbose             Detailed logging
  -h, --help                Show this help
      --version             Show version

${BOLD}DIFFERENCES FROM v2 (shell-only)${NC}
  â€¢ Claude Code runs in INTERACTIVE mode â€” full TUI, context bar visible
  â€¢ Handoff logic is enforced by hooks, not just instructions
  â€¢ Stop hook prevents exit until handoff files are written
  â€¢ /handoff, /status, /resume slash commands available
  â€¢ session-relay skill auto-activates for handoff protocol

${BOLD}EXAMPLES${NC}
  cleave my_prompt.md
  cleave --max-sessions 20 -d ./project prompt.md
  cleave --git-commit -m 15 research_task.md
  cleave --verify "pytest ./tests/ -x" --max-sessions 20 task.md
  cleave --resume-from 5 my_prompt.md

${BOLD}FILES${NC}
  .cleave/
  â”œâ”€â”€ PROGRESS.md              Status report (each session)
  â”œâ”€â”€ NEXT_PROMPT.md           Continuation prompt (by Claude)
  â”œâ”€â”€ KNOWLEDGE.md             Accumulated tips (grows over time)
  â”œâ”€â”€ status.json              Machine-readable status
  â””â”€â”€ logs/                    Full session archive
EOF
    exit 0
}

INITIAL_PROMPT=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -m|--max-sessions)
            if ! [[ "$2" =~ ^[0-9]+$ ]] || [ "$2" -lt 1 ] || [ "$2" -gt 1000 ]; then
                echo -e "${RED}Error: --max-sessions must be 1-1000${NC}"; exit 1
            fi
            MAX_SESSIONS="$2"; shift 2 ;;
        -d|--work-dir) WORK_DIR="$2"; shift 2 ;;
        -p|--pause)
            if ! [[ "$2" =~ ^[0-9]+$ ]]; then
                echo -e "${RED}Error: --pause must be a non-negative integer${NC}"; exit 1
            fi
            PAUSE_SECONDS="$2"; shift 2 ;;
        -c|--completion-marker) COMPLETION_MARKER="$2"; shift 2 ;;
        -g|--git-commit) GIT_COMMIT=true; shift ;;
        --no-notify) NOTIFY=false; shift ;;
        -r|--resume-from)
            if ! [[ "$2" =~ ^[0-9]+$ ]]; then
                echo -e "${RED}Error: --resume-from must be a non-negative integer${NC}"; exit 1
            fi
            RESUME_FROM="$2"; shift 2 ;;
        --verify) VERIFY_CMD="$2"; shift 2 ;;
        --safe-mode) SKIP_PERMISSIONS=false; shift ;;
        --plugin-dir) PLUGIN_DIR="$2"; shift 2 ;;
        -v|--verbose) VERBOSE=true; shift ;;
        -h|--help) usage ;;
        --version) echo "cleave v${VERSION} (plugin edition)"; exit 0 ;;
        -*) echo -e "${RED}Unknown option: $1${NC}"; usage ;;
        *)
            if [ -z "$INITIAL_PROMPT" ]; then
                INITIAL_PROMPT="$1"
            else
                echo -e "${RED}Error: unexpected argument '$1'${NC}"; usage
            fi
            shift ;;
    esac
done

if [ -z "$INITIAL_PROMPT" ]; then
    echo -e "${RED}Error: no initial prompt file specified.${NC}"
    echo ""; usage
fi

if [ ! -f "$INITIAL_PROMPT" ]; then
    echo -e "${RED}Error: prompt file not found: $INITIAL_PROMPT${NC}"; exit 1
fi

if ! command -v claude &> /dev/null; then
    echo -e "${RED}Error: 'claude' CLI not found. Install Claude Code first.${NC}"
    echo "  https://docs.anthropic.com/en/docs/claude-code"
    exit 1
fi

if [ -z "$PLUGIN_DIR" ] || [ ! -d "$PLUGIN_DIR/.claude-plugin" ]; then
    echo -e "${RED}Error: cleave plugin not found.${NC}"
    echo "  Expected at: ${PLUGIN_DIR:-<not set>}"
    echo "  Use --plugin-dir or run from the plugin directory."
    exit 1
fi

# â”€â”€ Setup paths â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
WORK_DIR=$(cd "$WORK_DIR" && pwd)
RELAY_DIR="$WORK_DIR/.cleave"
PROGRESS_FILE="$RELAY_DIR/PROGRESS.md"
NEXT_PROMPT_FILE="$RELAY_DIR/NEXT_PROMPT.md"
KNOWLEDGE_FILE="$RELAY_DIR/KNOWLEDGE.md"
STATUS_FILE="$RELAY_DIR/status.json"
LOG_DIR="$RELAY_DIR/logs"
SESSION_LOG="$LOG_DIR/relay.log"

mkdir -p "$LOG_DIR"
chmod 700 "$RELAY_DIR"

# â”€â”€ File locking â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
LOCK_FILE="$RELAY_DIR/.lock"
if command -v flock &> /dev/null; then
    exec 9> "$LOCK_FILE"
    if ! flock -n 9; then
        echo -e "${RED}Error: another cleave session is already running in $WORK_DIR${NC}"
        exit 1
    fi
    echo $$ > "$LOCK_FILE"
else
    if [ -f "$LOCK_FILE" ]; then
        lock_pid=$(cat "$LOCK_FILE" 2>/dev/null)
        if [ -n "$lock_pid" ] && kill -0 "$lock_pid" 2>/dev/null; then
            echo -e "${RED}Error: another cleave session is already running (PID $lock_pid).${NC}"
            exit 1
        fi
    fi
    echo $$ > "$LOCK_FILE"
fi

# Cleanup on exit
cleanup() {
    rm -f "$RELAY_DIR/.lock" "$RELAY_DIR/.active_relay" "$RELAY_DIR/.session_start" 2>/dev/null
}
trap cleanup EXIT INT TERM

# â”€â”€ Initialize files â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if [ ! -f "$KNOWLEDGE_FILE" ]; then
    cat > "$KNOWLEDGE_FILE" << 'KNOW'
# Accumulated Knowledge

## Core Knowledge
Persistent insights that matter for every session. Promote important
discoveries here â€” this section is never pruned.


## Session Log
Recent session notes (auto-pruned to last 5 sessions by the relay script).

KNOW
fi

# Mark this as an active relay session (read by hooks)
echo "1" > "$RELAY_DIR/.active_relay"
echo "0" > "$RELAY_DIR/.session_count"

# â”€â”€ Helper functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
log_msg() {
    local msg="[$(date '+%Y-%m-%d %H:%M:%S')] $1"
    echo -e "$msg"
    echo "$msg" | sed 's/\x1b\[[0-9;]*m//g' >> "$SESSION_LOG"
}

is_complete() {
    [ -f "$PROGRESS_FILE" ] && head -10 "$PROGRESS_FILE" | grep -qi "$COMPLETION_MARKER"
}

send_notification() {
    local title="$1" message="$2"
    [ "$NOTIFY" = false ] && return
    title="${title//\"/\\\"}" ; message="${message//\"/\\\"}"
    if [[ "$OSTYPE" == "darwin"* ]]; then
        osascript -e "display notification \"$message\" with title \"$title\"" 2>/dev/null || true
    elif command -v notify-send &> /dev/null; then
        notify-send "$title" "$message" 2>/dev/null || true
    fi
}

escape_json() {
    local str="$1"
    str="${str//\\/\\\\}" ; str="${str//\"/\\\"}"
    str="${str//$'\n'/\\n}" ; str="${str//$'\t'/\\t}"
    echo -n "$str"
}

write_status() {
    local session_num=$1 status=$2 message=$3
    cat > "$STATUS_FILE" << EOF
{
  "tool": "cleave",
  "version": "$VERSION",
  "session": $session_num,
  "max_sessions": $MAX_SESSIONS,
  "status": "$(escape_json "$status")",
  "message": "$(escape_json "$message")",
  "updated_at": "$(date -u '+%Y-%m-%dT%H:%M:%SZ')",
  "work_dir": "$(escape_json "$WORK_DIR")",
  "completion_marker": "$(escape_json "$COMPLETION_MARKER")"
}
EOF
}

run_verification() {
    [ -z "$VERIFY_CMD" ] && return 1
    log_msg "${CYAN}ğŸ” Running verification: ${VERIFY_CMD}${NC}"
    cd "$WORK_DIR" || return 1
    if bash -c "$VERIFY_CMD" > /dev/null 2>&1; then
        log_msg "${GREEN}âœ… Verification PASSED${NC}"
        return 0
    else
        log_msg "${DIM}  Verification returned non-zero â€” task not yet complete${NC}"
        return 1
    fi
}

git_commit_session() {
    local session_num=$1
    [ "$GIT_COMMIT" = false ] && return
    if [ -d "$WORK_DIR/.git" ]; then
        cd "$WORK_DIR" || return
        git add -A 2>/dev/null
        local changes
        changes=$(git diff --cached --stat 2>&1)
        if [ -n "$changes" ]; then
            git commit -m "cleave: session #${session_num} checkpoint" --no-verify 2>/dev/null && \
                log_msg "${DIM}  Git: committed session #${session_num}${NC}"
        fi
    fi
}

check_rate_limit() {
    local session_output="$1"
    [ ! -f "$session_output" ] && return 1
    if grep -qi "usage limit\|rate limit\|too many requests\|limit reached" "$session_output" 2>/dev/null; then
        log_msg "${YELLOW}â³ Rate limit detected. Waiting 5 minutes...${NC}"
        send_notification "cleave" "Rate limit hit. Waiting for reset..."
        local remaining=300
        while [ $remaining -gt 0 ]; do
            printf "\r  ${DIM}Rate limit reset in: %02d:%02d${NC}  " $((remaining/60)) $((remaining%60))
            local tick=10; [ $remaining -lt 10 ] && tick=$remaining
            sleep $tick; remaining=$((remaining - tick))
        done
        printf "\r  ${GREEN}Rate limit should be lifted.${NC}          \n"
        return 0
    fi
    return 1
}

# â”€â”€ Banner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
echo ""
echo -e "${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
echo -e "${BOLD}â•‘  ${CYAN}cleave${NC} ${DIM}v${VERSION} (plugin edition)${NC}${BOLD}                     â•‘${NC}"
echo -e "${BOLD}â•‘  ${DIM}Infinite context for Claude Code${NC}${BOLD}                        â•‘${NC}"
echo -e "${BOLD}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£${NC}"
echo -e "${BOLD}â•‘${NC}  Plugin:      ${BLUE}$(basename "$PLUGIN_DIR")${NC}"
echo -e "${BOLD}â•‘${NC}  Work dir:    ${BLUE}$(basename "$WORK_DIR")${NC}"
echo -e "${BOLD}â•‘${NC}  Max sessions:${BLUE} $MAX_SESSIONS${NC}"
echo -e "${BOLD}â•‘${NC}  Git commit:  ${BLUE} $GIT_COMMIT${NC}"
if [ -n "$VERIFY_CMD" ]; then
echo -e "${BOLD}â•‘${NC}  Verify cmd:  ${BLUE} $VERIFY_CMD${NC}"
fi
if [ "$RESUME_FROM" -gt 0 ]; then
echo -e "${BOLD}â•‘${NC}  Resume from: ${YELLOW} session #$RESUME_FROM${NC}"
fi
echo -e "${BOLD}â•‘${NC}  Mode:        ${GREEN} Interactive TUI âœ“${NC}"
echo -e "${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
echo ""

log_msg "${DIM}cleave started (plugin edition)${NC}"
log_msg "${DIM}Plugin: $PLUGIN_DIR${NC}"
log_msg "${DIM}Initial prompt: $INITIAL_PROMPT${NC}"

# â”€â”€ Main relay loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SESSION_COUNT=$RESUME_FROM
CONSECUTIVE_FAILURES=0
SESSION_OUTPUT=$(mktemp)
trap "rm -f '$SESSION_OUTPUT'; cleanup" EXIT INT TERM

while [ $SESSION_COUNT -lt $MAX_SESSIONS ]; do
    SESSION_COUNT=$((SESSION_COUNT + 1))

    # Check completion
    if is_complete; then
        log_msg "${GREEN}âœ… Task complete after session #$((SESSION_COUNT - 1))!${NC}"
        write_status $((SESSION_COUNT - 1)) "complete" "All done"
        send_notification "cleave âœ…" "Task complete after $((SESSION_COUNT - 1)) sessions!"
        git_commit_session $((SESSION_COUNT - 1))
        exit 0
    fi

    # Loop detection
    if "$PLUGIN_DIR/scripts/loop-detect.sh" "$RELAY_DIR" "$SESSION_COUNT" 2>/dev/null; then
        CONSECUTIVE_FAILURES=$((CONSECUTIVE_FAILURES + 1))
        if [ $CONSECUTIVE_FAILURES -ge 3 ]; then
            log_msg "${RED}âŒ 3 consecutive loops detected. Stopping.${NC}"
            write_status $SESSION_COUNT "stuck" "Loop detected 3 times"
            send_notification "cleave âŒ" "Stopped: agent stuck in a loop."
            exit 2
        fi
        log_msg "${YELLOW}  Loop warning (attempt $CONSECUTIVE_FAILURES of 3)${NC}"
    else
        CONSECUTIVE_FAILURES=0
    fi

    # Compact knowledge
    "$PLUGIN_DIR/scripts/compact-knowledge.sh" "$KNOWLEDGE_FILE" "$KNOWLEDGE_KEEP_SESSIONS" 2>/dev/null || true

    # Build the prompt
    echo ""
    echo -e "${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    log_msg "${BOLD}SESSION #${SESSION_COUNT}${NC} of ${MAX_SESSIONS}"
    echo -e "${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""

    write_status $SESSION_COUNT "running" "Session #$SESSION_COUNT active"

    # Determine the prompt source
    CLAUDE_PROMPT=""
    if [ "$SESSION_COUNT" -gt 1 ] && [ -f "$NEXT_PROMPT_FILE" ]; then
        CLAUDE_PROMPT=$(cat "$NEXT_PROMPT_FILE")
    else
        CLAUDE_PROMPT=$(cat "$INITIAL_PROMPT")
        if [ -f "$PROGRESS_FILE" ]; then
            CLAUDE_PROMPT="$CLAUDE_PROMPT

--- PROGRESS FROM PRIOR SESSIONS ---
$(cat "$PROGRESS_FILE")"
        fi
    fi

    # Append knowledge reference
    if [ -f "$KNOWLEDGE_FILE" ] && [ "$(wc -l < "$KNOWLEDGE_FILE" | tr -d ' ')" -gt 10 ]; then
        CLAUDE_PROMPT="$CLAUDE_PROMPT

--- ACCUMULATED KNOWLEDGE ---
Read \`.cleave/KNOWLEDGE.md\` for tips and patterns from prior sessions."
    fi

    # Archive prompt
    echo "$CLAUDE_PROMPT" > "$LOG_DIR/session_${SESSION_COUNT}_prompt.md"

    # Touch session start marker (for the stop hook to compare against)
    touch "$RELAY_DIR/.session_start"
    echo "$SESSION_COUNT" > "$RELAY_DIR/.session_count"

    # â”€â”€ Launch Claude Code with the plugin â”€â”€
    cd "$WORK_DIR" || { log_msg "${RED}Cannot cd to $WORK_DIR${NC}"; exit 1; }

    CLAUDE_ARGS=()
    CLAUDE_ARGS+=(--plugin-dir "$PLUGIN_DIR")
    [ "$SKIP_PERMISSIONS" = true ] && CLAUDE_ARGS+=(--dangerously-skip-permissions)

    # Pass prompt via -p (print mode) for non-interactive automation.
    # Interactive TUI requires manual input; for relay automation we need
    # the session to run unattended and exit when done.
    CLAUDE_ARGS+=(-p)

    echo "$CLAUDE_PROMPT" | claude "${CLAUDE_ARGS[@]}" 2>&1 | tee "$SESSION_OUTPUT"

    EXIT_CODE=${PIPESTATUS[0]:-$?}
    log_msg "${DIM}Session #${SESSION_COUNT} exited (code: $EXIT_CODE)${NC}"

    # Rate limit detection
    if check_rate_limit "$SESSION_OUTPUT"; then
        log_msg "${GREEN}Rate limit cleared. Retrying session #${SESSION_COUNT}...${NC}"
        SESSION_COUNT=$((SESSION_COUNT - 1))
        continue
    fi

    # Verification
    if run_verification; then
        log_msg "${GREEN}âœ… Verification passed â€” task objectively complete!${NC}"
        write_status $SESSION_COUNT "verified_complete" "Verification passed"
        send_notification "cleave âœ…" "Task verified complete after $SESSION_COUNT sessions!"
        git_commit_session $SESSION_COUNT
        exit 0
    fi

    # Archive outputs
    [ -f "$PROGRESS_FILE" ] && cp "$PROGRESS_FILE" "$LOG_DIR/session_${SESSION_COUNT}_progress.md"
    [ -f "$NEXT_PROMPT_FILE" ] && cp "$NEXT_PROMPT_FILE" "$LOG_DIR/session_${SESSION_COUNT}_next_prompt.md"
    [ -f "$KNOWLEDGE_FILE" ] && cp "$KNOWLEDGE_FILE" "$LOG_DIR/session_${SESSION_COUNT}_knowledge.md"

    # Git commit
    git_commit_session $SESSION_COUNT

    # Report
    if [ -f "$NEXT_PROMPT_FILE" ]; then
        local_size=$(wc -c < "$NEXT_PROMPT_FILE" | tr -d ' ')
        log_msg "${GREEN}Handoff received${NC} ${DIM}(${local_size} bytes)${NC}"
    else
        log_msg "${YELLOW}âš ï¸  No NEXT_PROMPT.md â€” will use initial prompt + PROGRESS.md${NC}"
    fi

    # Check completion
    if is_complete; then
        log_msg "${GREEN}âœ… Task complete after session #${SESSION_COUNT}!${NC}"
        write_status $SESSION_COUNT "complete" "All done"
        send_notification "cleave âœ…" "Task complete after $SESSION_COUNT sessions!"
        git_commit_session $SESSION_COUNT
        exit 0
    fi

    write_status $SESSION_COUNT "paused" "Between sessions"

    # Pause
    if [ $SESSION_COUNT -lt $MAX_SESSIONS ]; then
        log_msg "${DIM}Next session in ${PAUSE_SECONDS}s...${NC}"
        sleep "$PAUSE_SECONDS"
    fi
done

echo ""
log_msg "${YELLOW}âš ï¸  Reached max sessions ($MAX_SESSIONS). Task not yet complete.${NC}"
log_msg "${DIM}Resume: cleave --resume-from $SESSION_COUNT -m $((MAX_SESSIONS + 10)) $INITIAL_PROMPT${NC}"
write_status $SESSION_COUNT "max_sessions" "Stopped at session limit"
send_notification "cleave âš ï¸" "Reached $MAX_SESSIONS sessions. Task incomplete."
exit 1
